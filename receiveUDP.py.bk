import socket
import time
import serial

#UDP_IP_IN = "192.168.1.245"
UDP_IP_IN = "127.0.0.1"
#UDP_IP_OUT = "192.168.1.245"
UDP_PORT_IN = 5005
#UDP_PORT_OUT = 5006

#ser = serial.Serial('/dev/ttyAMA0', 9600)
#ser = serial.Serial('/dev/ttyACM0', 9600)

sock_in = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) # UDP from Control CPU
sock_in.setblocking(0)
sock_in.bind((UDP_IP_IN, UDP_PORT_IN))

#array holding step input values wheel mode motors[mot1, mot2, mot3]
step = [0,0,0]

#set up arrays
currentV = [0,0,0]
desired_motor = [0,0,0]
PID = [0,0,0]
error_motor = [0,0,0]

#variable to hold target angle of claw (position mode motor)
clawangle = 0

#Set PID Constants
kp = [.1, .1, .1]


while True:
	try:	
		data, addr = sock_in.recvfrom(1024) # buffer size is 1024 bytes
	#print "received message:", data
	except socket.error:
		data = "n/a"

	#each if/elif sets the value for each corresponding motor
	#may need to flip positive and negative values pending directions
	#currently set up to manually close/open claw with each keystroke
	if (data == "F"):
		step[1] = 10
	elif (data == "B"):
		step[1] = -10
	elif (data == "L"):
		step[0] = 10
	elif (data == "R"):
		step[0] = -10
	elif (data == "U"):
		step[2] = 10
	elif (data == "D"):
		step[2] = -10
	elif (data == "O"):
		clawangle = clawangle - 1
	elif (data == "C"):
		clawangle = clawangle + 1
	#else:
		#step = [0,0,0]

	print "step = ", step
	#print "clawangle = ", clawangle

	for i in range (0,2):
		error_motor[i] = desired_motor[i] + step[i] - currentV[i]
		PID[i] = kp[i] * error_motor[i]

	print error
	
	current = PID
	step = [0,0,0]

	time.sleep(.01)
